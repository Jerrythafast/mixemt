#!/usr/bin/python
"""

mixemt (Mix + EM + mitochondrial sequence)

This script implements an approach for deconvoluting mixtures of mitochondrial
sequences based on a known phylogeny from phylotree.org and an
Expectation-Maximization approach to estimate the number and relative
abundances of contributing haplotypes. Based on this information, reads are
assigned to sub-assemblies to reconstruct the haplotypes.

Outline of approach:

1. Identify all non-reference SNP variant sites that are present in this
sample.

2. Contruct a matrix of known mtDNA variants from phylotree and associated
haplotypes from phylotree.

3. EM algorithm to estimate contributing haplotypes and abundances.

4. Output fragments by contributing haplotype.

"""

import sys
import argparse
import pysam
import numpy

import phylotree
import preprocess
import em


def open_aln_file(sam_fn):
    """
    Opens the file specifed by the filename parameter and returns the
    AlignmentFile object. If the file cannot be opened, and error is printed
    and the program exits.
    """
    try:
        samfile = pysam.AlignmentFile(sam_fn, 'r')
        return samfile
    except (ValueError, IOError) as inst:
        sys.stderr.write("Error: %s\n" % (inst))
        sys.exit(1)
    return


def open_phylotree(phy_fn, args):
    """
    Opens the phylotree CSV file and uses the module "phylotree" to read in
    a list of variant positions and a table of haplogroups and associated
    variants.
    """
    try:
        with open(phy_fn, 'r') as phy_in:
            return phylotree.read_phylotree(phy_in, False, False, False)
    except (ValueError, IOError) as inst:
        sys.stderr.write("Error: %s\n" % (inst))
        sys.exit(1)
    return


def open_refseq(fa_fn):
    """
    Opens the FASTA formatted file specified by the fa_fn parameter and returns
    the sequence of the first entry as a string. If an error occurs an error is
    printed and the program exits.
    """
    try:
        fafile = pysam.FastaFile(fa_fn)
        return fafile.fetch(fafile.references[0]).upper()
    except (ValueError, IOError) as inst:
        sys.stderr.write("Error: %s\n" % (inst))
        sys.exit(1)
    return


def run_em_and_report(args):
    """
    This function takes all of the input from args and runs through the steps
    of preprocessing EM and interpretation.
    """

    # Load up the data.
    refseq  = open_refseq(args.ref_fn)
    samfile = open_aln_file(args.sam_fn)
    var_pos, hap_var = open_phylotree(args.phy_fn, args)

    # Build input for EM step
    em_mat, wts, haplogroups, read_sigs, sig_qids = \
        preprocess.build_em_input(samfile, refseq, var_pos, hap_var, args)

    for j in xrange(10):
        # Run EM
        est_mix, read_props = em.run_em(em_mat, wts, max_iter=100000)

        # Report the results
        order = numpy.argsort(est_mix)[::-1]
        for i in xrange(10):
            print i, est_mix[order[i]], haplogroups[order[i]]
        print

    return 0


def main():
    """ Reads input filenames from command line args and processes input
        through the analysis steps """
    parser = argparse.ArgumentParser("Estimates the number and proportions of "
                                     "contributing haplotypes.")
    parser.add_argument("ref_fn", metavar="ref.fasta", type=str,
                        help="FASTA file contain the reference sequence.")
    parser.add_argument("phy_fn", metavar="phylotree.csv", type=str,
                        help="Phylotree CSV file")
    parser.add_argument("sam_fn", metavar="reads.[sb]am", type=str,
                        help="Aligned reads in SAM/BAM format.")
    parser.add_argument('-q', '--min-MQ', dest='min_mq', type=int,
                        metavar="INT", default=30,
                        help="Skip alignments with mapQ < INT")
    parser.add_argument('-Q', '--min-BQ', dest='min_bq', type=int,
                        metavar="INT", default=30,
                        help="Skip bases with baseQ < INT")
    parser.add_argument('-v', '--verbose', action="store_true",
                        help="Print detailed status while running.")
    args = parser.parse_args()

    return run_em_and_report(args)


if __name__ == "__main__":
    sys.exit(main())
